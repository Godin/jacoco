/*******************************************************************************
 * Copyright (c) 2009, 2017 Mountainminds GmbH & Co. KG and Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Evgeny Mandrikov - initial API and implementation
 *
 *******************************************************************************/
package org.jacoco.core.internal.analysis;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;

final class Filters {

	interface IOutput {

		void ignore(AbstractInsnNode instruction);

		void ignoreJumpTarget(AbstractInsnNode instruction);

		void remapJump(AbstractInsnNode original, AbstractInsnNode remapped);

	}

	static void filter(final MethodNode methodNode, final IOutput output) {
		// TODO is check of null only for tests?
		if (methodNode.tryCatchBlocks != null) {
			for (TryCatchBlockNode tryCatch : methodNode.tryCatchBlocks) {
				filterSync(tryCatch, output);
			}
		}

		AbstractInsnNode i = methodNode.instructions.getFirst();
		while (i != null) {
			if (isStringSwitchStart(i)) {
				filterStringSwitch(i, output);
			}
			i = i.getNext();
		}
	}

	private static void filterSync(final TryCatchBlockNode tryCatch,
			final IOutput output) {
		if (tryCatch.type != null) {
			return;
		}
		if (tryCatch.start == tryCatch.handler) {
			return;
		}

		// TODO ECJ

		Seq exceptionPath = match(nextInstructionSkipFrames(tryCatch.handler),
				new int[] { Opcodes.ASTORE, Opcodes.ALOAD, Opcodes.MONITOREXIT,
						Opcodes.ALOAD, Opcodes.ATHROW });
		if (exceptionPath == null) {
			return;
		}

		for (AbstractInsnNode i = exceptionPath.first; i != exceptionPath.last; i = i
				.getNext()) {
			output.ignore(i);
		}
	}

	private static Seq match(AbstractInsnNode start, int[] opcodes) {
		AbstractInsnNode current = start;
		for (int opcode : opcodes) {
			if (current.getOpcode() != opcode) {
				return null;
			}
			do {
				current = current.getNext();
			} while (current.getType() == AbstractInsnNode.LABEL
					|| current.getType() == AbstractInsnNode.FRAME);
		}
		return new Seq(start, current.getPrevious());
	}

	static class Seq {
		private final AbstractInsnNode first;
		private final AbstractInsnNode last;

		Seq(AbstractInsnNode first, AbstractInsnNode last) {
			this.first = first;
			this.last = last;
		}
	}

	/**
	 * @return next instruction that is not frame
	 */
	private static AbstractInsnNode nextInstructionSkipFrames(
			AbstractInsnNode i) {
		do {
			i = i.getNext();
		} while (i.getType() == AbstractInsnNode.FRAME);
		return i;
	}

	/**
	 * Returns <code>true</code> if given instruction is {@code LOOKUPSWITCH} or
	 * {@code TABLESWITCH} preceded by
	 * {@code INVOKEVIRTUAL java/lang/String.hashCode ()I}.
	 */
	private static boolean isStringSwitchStart(
			final AbstractInsnNode instruction) {
		if (instruction.getOpcode() == Opcodes.LOOKUPSWITCH
				|| instruction.getOpcode() == Opcodes.TABLESWITCH) {
			final AbstractInsnNode previous = instruction.getPrevious();
			if (previous.getOpcode() == Opcodes.INVOKEVIRTUAL) {
				final MethodInsnNode m = ((MethodInsnNode) previous);
				return "java/lang/String".equals(m.owner)
						&& "hashCode".equals(m.name);
			}
		}
		return false;
	}

	/**
	 * Filters code that is generated for String in switch statement (Java 7).
	 *
	 * Code generated by javac is easy to filter - everything up to a final
	 * switch should be ignored:
	 *
	 * <pre>
	 *     LOOKUPSWITCH
	 *     h1: ...
	 *     IFEQ h1_2
	 *     ...
	 *     h1_2: ...
	 *     IFEQ after_h
	 *     ...
	 *     GOTO after_h
	 *     h2: ...
	 *     IFEQ after_h
	 *     after_h:
	 *     TABLESWITCH
	 *     c1: ...
	 *     c2: ...
	 *     c3: ...
	 *     default: ...
	 * </pre>
	 * 
	 * Code generated by ECJ is more tricky to handle, because it contains only
	 * one switch:
	 *
	 * <pre>
	 *     LOOKUPSWITCH  // or TABLESWITCH
	 *     h1: ...
	 *     IFNE c1
	 *     ...
	 *     IFNE c2
	 *     GOTO default
	 *     h2: ...
	 *     IFNE c2
	 *     GOTO default  // won't appear if default case is a first one
	 *     c1: ...
	 *     c2: ...
	 *     c3: ...
	 *     default: ...
	 * </pre>
	 */
	private static void filterStringSwitch(final AbstractInsnNode start,
			final IOutput output) {
		boolean javac = true;
		AbstractInsnNode i = start;

		final LabelNode dflt;
		final int hashCodes;
		if (i.getOpcode() == Opcodes.LOOKUPSWITCH) {
			dflt = ((LookupSwitchInsnNode) i).dflt;
			hashCodes = ((LookupSwitchInsnNode) i).labels.size();
		} else {
			dflt = ((TableSwitchInsnNode) i).dflt;
			hashCodes = ((TableSwitchInsnNode) i).labels.size();
		}
		i = i.getNext();
		for (int h = 0; h < hashCodes; h++) {
			output.ignoreJumpTarget(nextInstructionSkipFrames(i));
			do {
				output.ignore(i);
				if (i.getOpcode() == Opcodes.IFNE) {
					javac = false;
					output.remapJump(i, start);
				}
				i = i.getNext();
			} while (i.getType() != AbstractInsnNode.LABEL);
		}

		if (javac) {
			i = start;
			do {
				output.ignore(i);
				i = i.getNext();
			} while (i != dflt);
		}
	}

}
